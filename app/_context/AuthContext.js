"use client";

import {
  createContext,
  useContext,
  useEffect,
  useState,
  useMemo,
  useCallback,
  useRef,
} from "react";
import { auth } from "../_utils/firebase";
import { onAuthStateChanged, signOut } from "firebase/auth";
import GlobalApi from "../_utils/GlobalApi";
import { useRouter } from "next/navigation";
import nookies from 'nookies';
import { usePathname } from 'next/navigation';

const AuthContext = createContext({});

export const useAuth = () => useContext(AuthContext);

// Th·ªùi gian h·∫øt h·∫°n m·∫∑c ƒë·ªãnh c·ªßa Firebase Token (1 gi·ªù)
const TOKEN_EXPIRY_TIME = 60 * 60 * 1000; // 1 gi·ªù t√≠nh b·∫±ng ms
// L√†m m·ªõi tr∆∞·ªõc 5 ph√∫t khi h·∫øt h·∫°n
const REFRESH_TIME_BEFORE_EXPIRY = 5 * 60 * 1000; // 5 ph√∫t t√≠nh b·∫±ng ms
// Th·ªùi h·∫°n cookie: 1 nƒÉm
const COOKIE_MAX_AGE = 365 * 24 * 60 * 60; // 1 nƒÉm t√≠nh b·∫±ng gi√¢y

// Danh s√°ch c√°c ƒë∆∞·ªùng d·∫´n c√¥ng khai
const PUBLIC_PATHS = ['/sign-in', '/sign-up', '/forgot-password', '/reset-password', '/sign-out'];
const EXCLUDED_PATHS = ['/api', '/_next', '/static', '/favicon.ico', '/public', '/assets'];

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [profile, setProfile] = useState(null);
  const [loading, setLoading] = useState(true);
  const refreshTimerRef = useRef(null);
  const router = useRouter();
  const pathname = usePathname();

  // S·ª≠ d·ª•ng useCallback ƒë·ªÉ tr√°nh t·∫°o l·∫°i h√†m m·ªói khi component re-render
  const fetchUserProfile = useCallback(async (userId) => {
    try {
      const userProfile = await GlobalApi.getUserProfile(userId);
      if (userProfile) {
        setProfile(userProfile);
        return true;
      }
      return false;
    } catch (error) {
      console.error("Error fetching user profile:", error);
      return false;
    }
  }, []);

  // Khai b√°o logout tr∆∞·ªõc refreshToken ƒë·ªÉ tr√°nh l·ªói tham chi·∫øu
  const logout = useCallback(async () => {
    try {
      // D·ª´ng timer l√†m m·ªõi token n·∫øu ƒëang ch·∫°y
      if (refreshTimerRef.current) {
        clearTimeout(refreshTimerRef.current);
        refreshTimerRef.current = null;
      }

      // G·ªçi API ƒë·ªÉ x√≥a cookie
      await fetch("/api/auth/sign-out", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });

      // X√≥a d·ªØ li·ªáu t·ª´ localStorage
      localStorage.removeItem("tokenExpiryTime");

      // X√≥a cookie
      nookies.destroy(null, 'firebaseToken', { path: '/' });

      // ƒêƒÉng xu·∫•t kh·ªèi Firebase
      await signOut(auth);

      // Reset state
      setUser(null);
      setProfile(null);

      // Chuy·ªÉn h∆∞·ªõng v·ªÅ trang ƒëƒÉng nh·∫≠p
      router.push("/sign-in");
      
      return true;
    } catch (error) {
      console.error("L·ªói khi ƒëƒÉng xu·∫•t:", error);
      return false;
    }
  }, [router]);

  // H√†m ƒë·ªÉ l√†m m·ªõi token v√† l∆∞u v√†o cookie
  const refreshToken = useCallback(async (forceRefresh = true) => {
    try {
      const currentUser = auth.currentUser;
      if (!currentUser) return null;

      const idToken = await currentUser.getIdToken(forceRefresh);
      
      // S·ª≠ d·ª•ng nookies ƒë·ªÉ qu·∫£n l√Ω cookies ƒë·ªìng nh·∫•t
      nookies.set(null, 'firebaseToken', idToken, {
        maxAge: COOKIE_MAX_AGE,
        path: '/',
        sameSite: 'strict',
        secure: process.env.NODE_ENV !== 'development',
      });
      
      console.log("üîÑ ƒê√£ l√†m m·ªõi token Firebase");
      
      // L∆∞u th·ªùi ƒëi·ªÉm l√†m m·ªõi v√† th·ªùi ƒëi·ªÉm h·∫øt h·∫°n
      const expiryTime = Date.now() + TOKEN_EXPIRY_TIME;
      localStorage.setItem("tokenExpiryTime", expiryTime.toString());
      
      // Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ ƒëang ·ªü trang ƒëƒÉng nh·∫≠p kh√¥ng v√† t·ª± ƒë·ªông chuy·ªÉn h∆∞·ªõng
      const currentPath = window.location.pathname;
      if (currentPath === '/sign-in' || currentPath === '/sign-up') {
        console.log('üîÑ Token ƒë√£ ƒë∆∞·ª£c l√†m m·ªõi, chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ch·ªß...');
        // Chuy·ªÉn h∆∞·ªõng b·∫±ng window.location ƒë·ªÉ ƒë·∫£m b·∫£o trang ƒë∆∞·ª£c t·∫£i l·∫°i
        setTimeout(() => {
          window.location.href = '/';
        }, 300);
      }
      
      return idToken;
    } catch (error) {
      console.error("‚ùå L·ªói khi l√†m m·ªõi token Firebase:", error);
      
      // Ki·ªÉm tra l·ªói li√™n quan ƒë·∫øn t√†i kho·∫£n b·ªã v√¥ hi·ªáu
      if (
        error.code === 'auth/user-token-expired' || 
        error.code === 'auth/user-disabled' || 
        error.code === 'auth/user-not-found' ||
        error.code === 'auth/id-token-expired'
      ) {
        console.log("üö´ T√†i kho·∫£n kh√¥ng h·ª£p l·ªá ho·∫∑c b·ªã v√¥ hi·ªáu h√≥a");
        await logout();
      }
      
      return null;
    }
  }, [logout]);

  // H√†m thi·∫øt l·∫≠p h·∫πn gi·ªù l√†m m·ªõi token
  const setupTokenRefresh = useCallback((currentUser) => {
    // X√≥a h·∫πn gi·ªù c≈© n·∫øu c√≥
    if (refreshTimerRef.current) {
      clearTimeout(refreshTimerRef.current);
    }

    // L·∫•y th·ªùi gian h·∫øt h·∫°n token t·ª´ localStorage
    const expiryTime = localStorage.getItem("tokenExpiryTime");
    const now = Date.now();
    
    // T√≠nh th·ªùi gian c·∫ßn l√†m m·ªõi token (5 ph√∫t tr∆∞·ªõc khi h·∫øt h·∫°n)
    let timeUntilRefresh;
    
    if (expiryTime && parseInt(expiryTime) > now) {
      timeUntilRefresh = Math.max(
        0, 
        parseInt(expiryTime) - now - REFRESH_TIME_BEFORE_EXPIRY
      );
    } else {
      // L√†m m·ªõi ngay l·∫≠p t·ª©c n·∫øu kh√¥ng c√≥ th·ªùi gian h·∫øt h·∫°n ho·∫∑c ƒë√£ h·∫øt h·∫°n
      refreshToken(true);
      // ƒê·∫∑t th·ªùi gian l√†m m·ªõi ti·∫øp theo l√† 55 ph√∫t
      timeUntilRefresh = TOKEN_EXPIRY_TIME - REFRESH_TIME_BEFORE_EXPIRY;
    }
    
    console.log(`‚è±Ô∏è ƒê·∫∑t l·ªãch l√†m m·ªõi token sau ${Math.floor(timeUntilRefresh/60000)} ph√∫t`);
    
    // Thi·∫øt l·∫≠p h·∫πn gi·ªù m·ªõi
    refreshTimerRef.current = setTimeout(async () => {
      console.log("‚è±Ô∏è ƒê·∫øn th·ªùi gian l√†m m·ªõi token Firebase");
      if (auth.currentUser) {
        await refreshToken(true);
        // Thi·∫øt l·∫≠p l·∫°i h·∫πn gi·ªù cho l·∫ßn l√†m m·ªõi ti·∫øp theo
        setupTokenRefresh(auth.currentUser);
      }
    }, timeUntilRefresh);
  }, [refreshToken]);

  // Ki·ªÉm tra v√† chuy·ªÉn h∆∞·ªõng d·ª±a tr√™n tr·∫°ng th√°i ƒëƒÉng nh·∫≠p v√† ƒë∆∞·ªùng d·∫´n hi·ªán t·∫°i
  useEffect(() => {
    // B·ªè qua ki·ªÉm tra khi ƒëang t·∫£i ho·∫∑c kh√¥ng c√≥ router/pathname
    if (loading || !pathname) return;

    console.log(`üß≠ ƒêang ki·ªÉm tra ƒë∆∞·ªùng d·∫´n: ${pathname}`);

    // Ki·ªÉm tra n·∫øu l√† ƒë∆∞·ªùng d·∫´n lo·∫°i tr·ª´ (API, t·ªáp tƒ©nh, v.v.)
    if (EXCLUDED_PATHS.some(path => pathname.startsWith(path))) {
      console.log(`‚è© B·ªè qua ƒë∆∞·ªùng d·∫´n ƒë·∫∑c bi·ªát: ${pathname}`);
      return;
    }

    // Ki·ªÉm tra xem ƒë∆∞·ªùng d·∫´n c√≥ ph·∫£i l√† c√¥ng khai kh√¥ng
    const isPublicPath = PUBLIC_PATHS.some(
      path => pathname === path || pathname.startsWith(`${path}/`)
    );

    if (isPublicPath) {
      console.log(`üîì ƒê∆∞·ªùng d·∫´n c√¥ng khai: ${pathname}`);
    } else {
      console.log(`üîí ƒê∆∞·ªùng d·∫´n ƒë∆∞·ª£c b·∫£o v·ªá: ${pathname}`);
    }

    // Ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p v√† ƒëang truy c·∫≠p trang ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
    // X·ª≠ l√Ω case n√†y tr∆∞·ªõc ƒë·ªÉ ∆∞u ti√™n chuy·ªÉn h∆∞·ªõng ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p
    if (user && (pathname === '/sign-in' || pathname === '/sign-up')) {
      console.log(`‚úÖ Ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p, chuy·ªÉn h∆∞·ªõng t·ª´ ${pathname} ƒë·∫øn trang ch·ªß`);
      // D√πng setTimeout ƒë·ªÉ ƒë·∫£m b·∫£o chuy·ªÉn h∆∞·ªõng x·∫£y ra sau khi t·∫•t c·∫£ state ƒë∆∞·ª£c c·∫≠p nh·∫≠t
      setTimeout(() => {
        router.push('/');
      }, 100);
      return;
    }

    // Ng∆∞·ªùi d√πng ch∆∞a ƒëƒÉng nh·∫≠p v√† ƒëang truy c·∫≠p ƒë∆∞·ªùng d·∫´n ƒë∆∞·ª£c b·∫£o v·ªá
    if (!user && !isPublicPath) {
      console.log(`‚õî Ng∆∞·ªùi d√πng ch∆∞a ƒëƒÉng nh·∫≠p, chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ƒëƒÉng nh·∫≠p t·ª´ ${pathname}`);
      router.replace('/sign-in');
      return;
    }

    console.log(`‚úì Cho ph√©p truy c·∫≠p: ${pathname}`);
  }, [user, loading, pathname, router]);

  useEffect(() => {
    let unsubscribe;
    let isMounted = true; // S·ª≠ d·ª•ng bi·∫øn ƒë·ªÉ ki·ªÉm tra component c√≤n mounted kh√¥ng

    const initAuth = async () => {
      // L·∫Øng nghe s·ª± thay ƒë·ªïi tr·∫°ng th√°i x√°c th·ª±c t·ª´ Firebase
      unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
        if (!isMounted) return; // Tr√°nh c·∫≠p nh·∫≠t state n·∫øu component ƒë√£ unmounted

        if (firebaseUser) {
          console.log("üë§ Ph√°t hi·ªán ng∆∞·ªùi d√πng Firebase:", firebaseUser.email);
          
          setUser(firebaseUser);
          await fetchUserProfile(firebaseUser.uid);
          
          // L√†m m·ªõi token v√† thi·∫øt l·∫≠p h·∫πn gi·ªù
          await refreshToken(false); // false ƒë·ªÉ tr√°nh l√†m m·ªõi kh√¥ng c·∫ßn thi·∫øt
          setupTokenRefresh(firebaseUser);
        } else {
          console.log("üë§ Kh√¥ng c√≥ ng∆∞·ªùi d√πng Firebase ƒëƒÉng nh·∫≠p");
          setUser(null);
          setProfile(null);
          
          // X√≥a h·∫πn gi·ªù l√†m m·ªõi token
          if (refreshTimerRef.current) {
            clearTimeout(refreshTimerRef.current);
            refreshTimerRef.current = null;
          }
        }

        if (isMounted) setLoading(false);
      });
    };

    // Kh·ªüi t·∫°o x√°c th·ª±c ngay khi component mount
    initAuth();

    return () => {
      isMounted = false;
      if (unsubscribe) unsubscribe();
      // D·ªçn d·∫πp h·∫πn gi·ªù khi component unmount
      if (refreshTimerRef.current) {
        clearTimeout(refreshTimerRef.current);
        refreshTimerRef.current = null;
      }
    };
  }, [fetchUserProfile, setupTokenRefresh, refreshToken]);

  // Th√™m h√†m ƒë·ªÉ x√°c th·ª±c token ·ªü server-side
  const verifyTokenServer = useCallback(async () => {
    try {
      console.log('üîç ƒêang g·ª≠i request x√°c th·ª±c token ƒë·∫øn API...');
      
      // ƒê·∫£m b·∫£o g·ª≠i credentials ƒë·ªÉ cookie ƒë∆∞·ª£c g·ª≠i c√πng request
      const response = await fetch('/api/auth/verify-token', {
        method: 'GET',
        credentials: 'include', // Quan tr·ªçng: ƒë·∫£m b·∫£o cookie ƒë∆∞·ª£c g·ª≠i
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });
      
      const data = await response.json();
      
      if (!response.ok || !data.valid) {
        console.error('‚ùå Token kh√¥ng h·ª£p l·ªá:', data.message || response.statusText);
        return false;
      }
      
      console.log('‚úÖ Token h·ª£p l·ªá, h·∫øt h·∫°n:', data.expiresAt);
      return true;
    } catch (error) {
      console.error('‚ùå L·ªói x√°c th·ª±c token:', error);
      return false;
    }
  }, []);

  // Ki·ªÉm tra token h·ª£p l·ªá ch·ªâ sau khi token ƒë√£ ƒë∆∞·ª£c l√†m m·ªõi
  useEffect(() => {
    let tokenCheckTimeout;
    
    const checkToken = async () => {
      // B·ªè qua ki·ªÉm tra n·∫øu ƒëang trong qu√° tr√¨nh loading ho·∫∑c kh√¥ng c√≥ user
      if (loading || !user) return;
      
      // ƒê√£ ph√°t hi·ªán ƒëƒÉng nh·∫≠p th√†nh c√¥ng, ƒë·∫£m b·∫£o ng∆∞·ªùi d√πng ƒë∆∞·ª£c chuy·ªÉn h∆∞·ªõng kh·ªèi trang ƒëƒÉng nh·∫≠p
      if (window.location.pathname === '/sign-in' || window.location.pathname === '/sign-up') {
        console.log('üîÑ ƒêƒÉng nh·∫≠p th√†nh c√¥ng, chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ch·ªß...');
        window.location.href = '/'; // D√πng window.location ƒë·ªÉ ƒë·∫£m b·∫£o chuy·ªÉn h∆∞·ªõng x·∫£y ra
        return;
      }
      
      // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o token ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o cookie
      tokenCheckTimeout = setTimeout(async () => {
        console.log('üîÑ B·∫Øt ƒë·∫ßu ki·ªÉm tra token server-side...');
        
        // Ki·ªÉm tra token
        const isValid = await verifyTokenServer();
        
        // N·∫øu token kh√¥ng h·ª£p l·ªá, ƒëƒÉng xu·∫•t
        if (!isValid) {
          console.log('üö´ Token kh√¥ng h·ª£p l·ªá, ƒëƒÉng xu·∫•t');
          await logout();
        } else {
          console.log('‚úÖ X√°c th·ª±c token th√†nh c√¥ng!');
        }
      }, 1000); // ƒê·ª£i 1s sau khi user ƒë∆∞·ª£c x√°c ƒë·ªãnh
    };
    
    checkToken();
    
    return () => {
      if (tokenCheckTimeout) clearTimeout(tokenCheckTimeout);
    };
  }, [loading, user, verifyTokenServer, logout]);

  // S·ª≠ d·ª•ng useMemo ƒë·ªÉ tr√°nh t·∫°o l·∫°i object context m·ªói khi component re-render
  const contextValue = useMemo(
    () => ({
      user,
      profile,
      setProfile,
      loading,
      logout,
      refreshToken,
      verifyTokenServer,
      isAuthenticated: !!user,
    }),
    [user, profile, loading, logout, refreshToken, verifyTokenServer]
  );

  return (
    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>
  );
}
